|----------|
| TUTORIAL |
|----------|------------------|
| Introductory Fuga tutorial. |
| Author: Francisco Mota.     |
| Date:   October 10, 2010    |
|-----------------------------|

# Preliminaries

To run fuga, open a command-line/terminal and do

    $ python fuga.py

This opens up a REPL (Read Eval Print loop)-style interpreter.

To run a specific fuga module, do

    $ python fuga.py filename

There are some examples in the `examples` folder. So, to run `hello.fg` in
the `examples` folder, type

    $ python fuga.py examples/hello.fg

And it should print "Hello, world!" to the screen. 

# Basics

## Primitive Objects

Fuga is an object-oriented programming language. As a result, all values
are objects. Some values are built-in to the language (although they are
still objects) and we call those primitives. Primitives can be numbers,
strings, and messages. For example, `123` is a number primitive, `"Hello,
world!"` is a string primitive, and `foo` is a message primitive.

When evaluated, strings and numbers evaluate to themselves. Open the fuga
interpreter, and once the prefix (`>>>`) shows up, type

    >>> 123
    123
    >>> "Hello, world!"
    "Hello, world!"
    >>>

You can type quit or press Ctrl-D to end the session.

    >>> quit
    Goodbye.

## Messages

Messages are sent to objects in order to inspect or direct objects. For
example, we can find out the length of a string by sending it the `len`
message.

    >>> "Hello, world!" len
    13

Messages can contain arguments. For example, `find` lets you find the
first occurence of a substring within a string. If it finds the string,
it will return the index. If it can't find the substring, it returns -1.

    >>> "Hello, world!" find("world")
    7
    >>> "Hello, world!" find("Goodbye")
    -1

Some messages can have a variable number of arguments. For example,
`slice` can have one or two arguments. `slice` returns a substring (or a
slice) of the original string. If the second argument is omitted, the
substring goes to the end of the string.

    >>> "Hello!" slice(1)
    "ello!"
    >>> "Hello!" slice(1,4)
    "ell"

You can send multiple messages, in sequence. For example,

    >>> "Hello!" slice(1) find("!")
    4
    >>> "Hello!" slice(1) slice(1,4) len
    3

Some messages are operators, which can pass their arguments without
enclosing them in parentheses.

    >>> 2 + 2
    4
    >>> 1 - 2
    -1
    >>> 1 * 2 + 3
    5
    >>> 1 + 2 * 3
    7

You can choose to use operators like any other message, however, by
either following them directly with parentheses, or by escaping the
operator with a backslash (\)

    >>> 1 +(2) *(3)
    9
    >>> 1 \+(2) \*(3)
    9

Here, the object `1` is sent the message `+(2)`, and the result is sent
the message `*(3)`.

## Objects and Object Literals

Objects are a sequence of slots. Slots have values, and some slots have
names. You can create your own objects by using object literals. Object
literals are enclosed in parentheses (`()`).

This is an empty object:

    >>> ()
    ()

This object contains one slot, with the value `10`:

    >>> (10)
    (10)

This object contains two slots, with the values `10` and `20`:

    >>> (10, 20)
    (10, 20)

Note that a comma is used to separate slots. Newlines can also be used
to separate slots.

This object contains one slot, with the value `10`, and the name `foo`:

    >>> (foo=10)
    (foo=10)

Slot values can be arbitrary expressions.

    >>> (foo = 10 + 500 - 493, 100+1)
    (foo=17, 101)

When you send a message to an object, Fuga looks for the slot with the
name that corresponds to the message.

    >>> (foo=10) foo
    10

For that reason, you can't have two slots with the same name

    >>> (foo=10, foo=20)
    ERROR: Can't have two slots with name foo
    >>> (foo=10, foo=10)
    ERROR: Can't have two slots with name foo

# Methods

You can create your own methods by using the "becomes" operator.
For example, here we create a method the prints "Hello." We then
proceed to use it. Multiple times.

    >>> foo => print("Hello.")
    method(...)
    >>> foo
    Hello.
    Object
    >>> (foo, foo)
    Hello.
    Hello.
    (Object, Object)

(Object is just what print("Hello.") returns, so foo returns that as well.)

Arguments to the method can be specified after the slot name:

    >>> square(a) => a * a
    method(...)
    >>> square(10)
    100
    >>> fact(n) => if(n == 0, 1, n * fact(n - 1))
    method(...)
    >>> fact(3)
    6
    >>> fact(5)
    120

## Desugaring "becomes"

The becomes slot operator is syntactic sugar designed to make method
definition look closer to normal slot definitions. One can always use
`method` to create methods, without using "becomes":

    >>> fact = method(
    ...     (n), if(n == 0, 1, n * fact(n - 1))
    ... )
    method(...)
    >>> square = method((n), n * n)
    method(...)

"Becomes" can also be used on a slot without a name. This way, it really
is just a cover for method. The following two lines mean the same thing:

    >>> (a,b) => a + b
    >>> method((a,b), a + b)

## Pattern matching

When we write methods out the long way (without using "becomes"), we can
specify several possible argument lists, and fuga automatically tries
each argument list until it finds one that fits. For example, here is a
method that does something different based on whether one or two arguments
were given:

    >>> foo = method(
    ...     (a), print("one argument")
    ...     (a,b), print("two arguments")
    ... )
    method(...)
    >>> foo(10)
    one argument
    Object
    >>> foo(10,20)
    two arguments
    Object

We can use number and string literals in argument lists to match those
specific numbers / strings:

    >>> fact = method(
    ...     (0), 1
    ...     (n), fact(n - 1) * n
    ... )
    method(...)

To make such method definitions look nicer, we allow becomes to be used
inside "method":

    >>> fact = method(
    ...     (0) => 1
    ...     (n) => fact(n - 1) * n
    ... )
    method(...)
    >>> fib = method(
    ...     (0) => 0
    ...     (1) => 1
    ...     (n) => fib(n - 1) + fib(n - 2)
    ... )
    method(...)

## Call-by-name

We can prevent specific arguments from being evaluated altogether by
preceding the argument name with a quote. For example, the following
function works just like a quote:

    >>> quote('x) => x
    method(...)
    >>> quote(20)
    20
    >>> quote(print("Hello world!"))
    print("Hello world!")

Notice that the argument wasn't evaluated -- it was passed in as is.

We could use this to simulate conditional statements, loops, and other
things. For example, here is an if-like construct that will evaluate 
the second argument only if the first is 0, and will otherwise evaluate
the third argument.

    >>> myIf = method(
    ...     (0,  a, 'b) => a
    ...     (n, 'a,  b) => b
    ... )
    method(...)
    >>> myIf(1, print("left"), print("right"))
    right
    Object
    >>> myIf(2 - 2, print("left"), print("right))
    left
    Object

If we want to evaluate the arguments at a later point, we need the calling
environment. For this reason, methods that use call-by-name have access
to the calling environment through the "caller" message.

    >>> caller
    ERROR: no slot named caller
    >>> foo(a) => caller, foo(10)
    method(...)
    ERROR: no slot named caller
    >>> bar('a) => caller, bar(10)
    method(...)
    (foo=method(...), bar=method(...))

Access to `caller` allows us to create sophisticated looping mechanisms.
Here is an example of a non-sophisticated looping mechanism:

    >>> twice('a) => do(
    ...     caller eval(a)
    ...     caller eval(a)
    ... )
    method(...)
    >>> twice(10)
    10
    >>> twice(print("Hi!"))
    Hi!
    Hi!
    Object

Here, `twice` evaluates its argument twice.

## Self

When we use methods, we have access to the object that the method was
a part of. This is called `self`, and it is instrumental in allowing
us to use the object-oriented paradigm.

    >>> obj = (a = 10, foo => self)
    (a=10, foo=method(...))
    >>> obj a
    10
    >>> obj foo
    (a=10, foo=method(...))

# Prototyping

Fuga is a prototyping object-oriented programming language. In other
words, the vast majority of objects are created from another similar
object (called the prototype). In Fuga, if an objects slots don't
contain a certain name that we're looking for, we search its 
prototype, and so forth all the way down to Object.

Practically, this means that we can create new kinds of objects without
much work. If we wanted to make various kinds of cars, we'd just create
a Car object that will be used as a prototype for many cars. Alternatively,
we might decide to use a specific car, such as FordT, be a prototype for
many other cars, since they are all similar, rather than have all cars
be built upon a generic Car.

The first approach would go something like:

    >>> Car = (car? = true)
    ()
    >>> Ford = Car clone(make = "ford")
    (make="ford")
    >>> MercedesBenz = Car clone(make = "mercedes benz")
    (make="mercedes benz")
    >>> FordT = Ford clone(model = "ford T", color = "black")
    (color="black")

Here, clone is used to create a new object based on a prototype. Although
FordT only contains two slots (for "color" and "make"), we can still get
its `make`, because `Ford` is its prototype. We can also send `FordT` the
`car?` message, because `Ford`'s prototype is `Car`.

    >>> FordT color
    "black"
    >>> FordT make
    "ford"
    >>> FordT car?
    true

The second approach would be something like

    >>> FordT = (car? = true, make = "ford", model = "ford T", color = "black")
    >>> FordPanda = FordT clone(model = "ford panda")

The advantage of the second approach is that it leaves less generic objects
lying around (which could potentially be misused if they were treated as
non-generic objects). The second approach suffers from a lack of
hierarchy, however, and makes it difficult to make changes that affect
all cars. Most of the time, we'll use the first approach.

Here's another example of those two approachs. Natural numbers, and a 
possible way of doing the first approach:

    Nat = (
        zero? = false
        succ? = false
        succ  => Succ clone(pred = self)
    )

    zero = Nat clone(
        zero? = true
        +(b) => b
    )

    Succ = Nat clone(
        succ? = true
        +(b) => self pred +(b succ)
    )

Nat and Succ aren't generally useful in computations, but they let us
categorize the kinds of objects we're using, and they let us make changes
that will affect all natural numbers (for example).

The second approach:

    zero = (
        zero? = true
        succ? = false
        +(b) => b
        succ => zero clone(
            zero? = false
            succ? = true
            pred  = self
            +(b) => self pred +(b succ)
        )
    )

Here there aren't generic objects such as Nat and Succ floating around,
but in general you can't do quite as much as with the approach used above.
