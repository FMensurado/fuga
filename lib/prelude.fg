
:: Evaluate lazily.
lazy: fn((~x): x lazy)

:: Prevent evaluation of code.
"`":  fn((~x): x code)

:: Get slot without activating it.
:: Usually used to get a function without activating it.
".": fn(
    (~x): x scope get(x code)
    (recv, ~x): recv get(x code)
)

:: The last message receiver in a given scope.
Msg lastRecv := fn((scope): scope)

:: The last message receiver in a given scope.
Expr lastRecv := fn((scope):
    do(newExpr := Expr clone
       newExpr extend!(self)
       newExpr del(-1)
       newExpr eval(scope, scope))
)

:: The name of the last message.
Msg lastName := fn(self name)

:: The name of the last message.
Expr lastName := fn(self get(-1) lastName)

:: The last message receiver.
Thunk lastRecv := fn(self code lastRecv(self scope))

:: The last message name.
Thunk lastName := fn(self code lastName)

:: Get slot value from an index.
Object at := fn((index):
    if(isa?(index, Int), self get(index)
       TypeError raise("at: expected index to be an integer"))
)

:: Iterator using "self at" and "self len".
Object iter := fn(
    (_object: self
     _index: 0
     iter: fn(self copy)
     
     :: Are there any more values?
     done?: fn(self _index >= self _object len)

     :: The current value.
     value: fn(self _object at(self _index))

     :: Advance iterator.
     next!: fn(self _index = [self _index + 1]))
)

range: fn(
    (start, end):
        (len: end - start
         at: fn((n): start + n ))
    (start, end, step):
        (len: end - start + step - 1 // step
         at: fn((n): start + [n*step]))
)


:: Get empty version of container.
Object empty := fn(())

:: Map using iter.
:: With one argument, the argument is sent to all elements.
:: With two, the first argument is bound to each element, which is
:: usable in the second value. For example:
:: 
::     self map(*2)
::     self map(x: x*2)
Object map := fn(

# ideal version?:
#
# Object map := fn((^fn):
#     do(result := self empty
#        iter   := self iter
#        until(iter done?) do(
#            result append(fn(iter value))
#            iter next!
#        )
#        result)
# )

    (~body):
        if(body scope has?(:_key)
           aux(self iter, self empty
               fn((x):
                  do(scope := body scope clone
                     scope set!(body scope _key, x)
                     body code eval(scope, scope))
               )
           )
           aux(self iter, self empty
               fn((x): body code eval(x, body scope)))
        )

    aux: fn((iter, result, fn):
        if(iter done?
           result
           do(result append!(x: fn(iter value))
              iter next!
              aux(iter, result, .fn)))
    )
)

nil nil? := true
Object nil? := false

:: Add documentation to an existing slot.
:: Example:
::
::     :: New documentation.
::     redoc(existing slot)
redoc: fn((~x):
    x lastRecv setDoc!(x lastName, x scope get(:_doc))
)

#####################################################
################## Documentation ####################
#####################################################

:: String representation of self.
:: By convention, if self hasRaw(:_name), _name is returned instead.
redoc(Object str)

:: Does self or prototypes have a slot?
:: Look in prototypes if the object doesn't have a slot with the given
:: name. Do not look in prototypes if an index is used. A negative index
:: is used to indicate a slot starting from the end.
::
::     self has?(name)
::     self has?(index)
redoc(Object has?)

:: Get slot value in self or prototypes.
:: Look in prototypes if the object doesn't have a slot with the given
:: name. Do not look in prototypes if an index is used. A negative index
:: is used to indicate a slot starting from the end.
::
::     self get(name)
::     self get(index)
redoc(Object get)

:: Create slot or update slot value.
:: Do not touch prototypes -- affect only the called object directly.
:: 
::     self set!(name, value)
::     self set!(value, index)
redoc(Object set!)

:: Delete slot.
::
::     self del(name)
::     self del(index)
redoc(Object del)

:: Does self have a slot?
:: Do not look in prototypes.
::
::     self hasRaw?(name)
::     self hasRaw?(index)
redoc(Object hasRaw?)

:: Get slot value in self. 
:: Do not look in prototypes.
::
::     self getRaw(name)
::     self getRaw(index)
redoc(Object getRaw)

:: Is a slot a named slot?
::
::     self hasName?(index)
redoc(Object hasName?)

:: Get the name associated with a slot.
:: 
::     self getName(index)
redoc(Object getName)

:: Does the given slot have documentation?
:: Looks for documentation in prototypes.
::
::     self hasDoc?(name)
::     self hasDoc?(index)
redoc(Object hasDoc?)

:: Get the documentation associated with a particular slot.
:: Looks for documentation in prototypes.
::
::     self getDoc(name)
::     self getDoc(index)
redoc(Object getDoc)

:: Set or change the documentation for a particular slot. 
:: Looks for the slot in prototypes.
::
::     self setDoc!(name, value)
::     self setDoc!(index, value)
redoc(Object setDoc!)

:: Match pattern to value.
:: Return a dictionary of captured names on success. Raise MatchError
:: on failure.
::
::     self match(value)
redoc(Object match)

:: Number of slots in self.
::
::     self len
redoc(Object len)

:: The slots of self, without prototype or primitive.
:: 
::     self slots
redoc(Object slots)

:: Directory of all messages that self replies to.
::
::     self dir
redoc(Object dir)

:: Add a slot to the object at the end.
:: Creates a new slot with the new highest index.
:: 
::     self append!(value)
redoc(Object append!)

:: Append all slots from the argument to self.
::
::     self extend!(other)
redoc(Object extend!)

:: Set all named slots from the argument to self.
:: 
::     self update!(other)
redoc(Object update!)

:: Evaluate code object.
:: Takes a lexical scope and a current message receiver (usually
:: the same). Irreflexive evaluation (slots can't be referenced
:: directly). Returns the evaluated value.
:: 
::     self eval(receiver, scope)
redoc(Object eval)

:: Evaluate code object reflexively.
:: Takes a lexical scope, which will be updated with the named
:: slots of the evaluated value.
::
::     self evalIn(scope)
redoc(Object evalIn)

:: The object's prototype.
:: Raises ValueError if there is no prototype (only happens for
:: Object).
::
::     self proto
redoc(Object proto)

:: Create a new object with prototype and given slots.
:: The prototype is self.
:: 
::     self clone(slots...)
redoc(Object clone)
